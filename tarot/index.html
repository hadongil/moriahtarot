<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>모리아의 신탁 v42.0 - 결과 화면 UI/UX 최종 개선</title>
    
    <!-- SEO 및 소셜 공유용 메타 태그 (내용을 실제 사이트에 맞게 수정하세요) -->
    <meta name="description" content="모리아의 신탁에서 오늘의 운세, 애정운, 사업운 등 다양한 타로점을 통해 삶의 지혜와 통찰을 얻으세요. 별들의 속삭임이 당신의 길을 안내합니다.">
    <meta name="keywords" content="타로, 타로점, 온라인타로, 오늘의운세, 애정운, 사업운, 금전운, 취업운, 모리아의신탁, 운세">
    <meta property="og:title" content="모리아의 신탁 - 온라인 타로">
    <meta property="og:description" content="별들의 속삭임에 귀를 기울여 보세요. 당신의 질문에 답을 드립니다.">
    <meta property="og:image" content="https://www.example.com/moriah-oracle/og-image.jpg">
    <meta property="og:url" content="https://www.example.com/moriah-oracle/">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto+Sans+KR:wght@300;400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css" />
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
    <script src="tarot_data.js" defer></script>

    <style>
        :root {
            --bg-dark: #0A091A;
            --primary: #C0B7E8;
            --text-light: #F0F0F8;
            --text-dark: #A1A1B5;
            --border-color: rgba(192, 183, 232, 0.25);
            --shadow-color: rgba(0, 0, 0, 0.5);
        }
        html, body { height: 100%; -webkit-text-size-adjust: 100%; }
        body { background-color: var(--bg-dark); color: var(--text-light); font-family: 'Pretendard', 'Noto Sans KR', sans-serif; margin: 0; overflow: hidden; -webkit-tap-highlight-color: transparent; }
        * { box-sizing: border-box; }
        h1, h2 { font-family: 'Cinzel', serif; font-weight: 700; letter-spacing: 0.1em; text-transform: uppercase; margin: 0; text-shadow: 0 0 15px rgba(255, 255, 255, 0.15); }
        h3 { font-family: 'Pretendard', sans-serif; font-weight: 600; margin: 0; }
        
        #celestial-background { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; overflow: hidden; }
        .star-layer { position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; background-repeat: repeat; transition: transform 2s ease-out; }
        #stars-far { background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="400" height="400"><circle fill="rgba(255,255,255,0.2)" cx="50" cy="50" r="0.5"/><circle fill="rgba(255,255,255,0.3)" cx="150" cy="250" r="0.7"/><circle fill="rgba(255,255,255,0.2)" cx="350" cy="100" r="0.5"/><circle fill="rgba(255,255,255,0.3)" cx="250" cy="150" r="0.6"/><circle fill="rgba(255,255,255,0.2)" cx="10" cy="350" r="0.5"/><circle fill="rgba(255,255,255,0.2)" cx="300" cy="300" r="0.5"/></svg>'); animation: move-stars-1 180s linear infinite; }
        #stars-mid { background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="600" height="600"><circle fill="rgba(255,255,255,0.4)" cx="100" cy="300" r="0.8"/><circle fill="rgba(255,255,255,0.5)" cx="400" cy="100" r="1"/><circle fill="rgba(255,255,255,0.4)" cx="500" cy="500" r="0.8"/><circle fill="rgba(255,255,255,0.5)" cx="50" cy="50" r="0.9"/><circle fill="rgba(255,255,255,0.4)" cx="250" cy="450" r="0.8"/><circle fill="rgba(255,255,255,0.4)" cx="550" cy="200" r="0.8"/></svg>'); animation: move-stars-2 120s linear infinite; }
        #stars-near { background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="800" height="800"><circle fill="rgba(255,255,255,0.7)" cx="200" cy="200" r="1.2"/><circle fill="rgba(255,255,255,0.6)" cx="600" cy="500" r="1.1"/><circle fill="rgba(255,255,255,0.8)" cx="50" cy="600" r="1.3"/><circle fill="rgba(255,255,255,0.7)" cx="750" cy="100" r="1.2"/><circle fill="rgba(255,255,255,0.6)" cx="400" cy="350" r="1.1"/></svg>'); animation: move-stars-3 60s linear infinite; }
        @keyframes move-stars-1 { from { transform: translate(0, 0); } to { transform: translate(-200px, 150px); } }
        @keyframes move-stars-2 { from { transform: translate(0, 0); } to { transform: translate(200px, -150px); } }
        @keyframes move-stars-3 { from { transform: translate(0, 0); } to { transform: translate(100px, 250px); } }
        #aurora { position: absolute; top: 50%; left: 50%; width: 140vmax; height: 140vmax; background: radial-gradient(circle, rgba(192, 183, 232, 0.15) 0%, rgba(232, 183, 226, 0.1) 30%, rgba(10, 9, 26, 0) 70%); animation: rotate-aurora 45s linear infinite; }
        @keyframes rotate-aurora { from { transform: translate(-50%, -50%) rotate(0deg); } to { transform: translate(-50%, -50%) rotate(360deg); } }

        #app-root { perspective: 2000px; height: 100%; width: 100%; position: relative; }
        .ui-layer { position: absolute; top:0; left:0; width:100%; height: 100%; text-align: center; display: flex; flex-direction: column; align-items: center; justify-content: center; will-change: opacity, transform; padding: 1rem; }
        
        .prompt h1 { font-size: clamp(2.2rem, 7vw, 2.8rem); }
        .prompt h2 { font-size: clamp(1.4rem, 5vw, 1.8rem); margin-bottom: 0.8rem; }
        .prompt p { font-size: clamp(0.95rem, 3vw, 1.05rem); color: var(--text-dark); max-width: 50ch; padding: 0 1rem; line-height: 1.6; }
        .prompt p.reveal-text { min-height: 3.2em; opacity: 0; } 
        
        #entry-gate, #celestial-pathway, #focus-altar, #focus-sanctum, #spread-table { opacity: 0; transform: translateZ(400px); pointer-events: none; }
        #entry-gate { opacity: 1; transform: translateZ(0); pointer-events: auto; }
        
        #orb-effects-container { position: absolute; width: 400px; height: 400px; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; }
        #orb-ground-light { position: absolute; bottom: -20px; left: 50%; width: 150px; height: 30px; background: radial-gradient(ellipse, rgba(192, 183, 232, 0.2) 0%, transparent 70%); border-radius: 50%; transform: translateX(-50%) scaleY(0.5); animation: pulse-ground-light 4s ease-in-out infinite; }
        @keyframes pulse-ground-light { 50% { opacity: 0.6; transform: translateX(-50%) scaleY(0.5) scaleX(1.1); } }
        
        #focus-sanctum { justify-content: flex-start; padding-top: clamp(1vh, 3vh, 5vh); }
        #focus-sanctum .prompt { flex-shrink: 0; margin-bottom: 1vh; }
        #constellation-map-container { position: relative; width: 100%; flex-grow: 1; max-width: 600px; display: flex; align-items: center; justify-content: center; }

        #constellation-svg { width: 100%; max-height: 100%; overflow: visible; }
        .star-node { cursor: pointer; transition: all 0.3s ease; fill: rgba(255, 255, 255, 0.7); }
        .star-glow { transition: all 0.3s ease; fill: var(--primary); stroke: var(--primary); stroke-width: 10px; opacity: 0.3; filter: blur(10px); }
        .star-label { fill: var(--text-light); font-family: 'Pretendard', sans-serif; font-size: 16px; pointer-events: none; opacity: 1; transition: opacity 0.5s ease; text-shadow: 0 0 5px var(--bg-dark); }
        .constellation-line { stroke: url(#line-gradient); stroke-width: 2px; stroke-opacity: 0.7; }

        #constellation-info-panel { position: absolute; bottom: 2%; left: 50%; transform: translateX(-50%); width: 90%; max-width: 500px; padding: 1rem 1.5rem; background-color: rgba(28, 26, 58, 0.4); border: 1px solid var(--border-color); border-radius: 1rem; backdrop-filter: blur(8px); text-align: center; opacity: 0; transition: opacity 0.5s ease, transform 0.5s ease; pointer-events: none; }
        #constellation-info-panel.visible { opacity: 1; transform: translateX(-50%) translateY(0); }
        #info-panel-title { font-family: 'Cinzel', serif; font-size: clamp(1.1rem, 4vw, 1.3rem); color: var(--primary); margin-bottom: 0.5rem; }
        #info-panel-desc { font-family: 'Pretendard', sans-serif; font-size: clamp(0.85rem, 3vw, 0.95rem); color: var(--text-dark); margin: 0; line-height: 1.5; }

        @media (max-width: 768px) { .star-label { font-size: 18px; } #constellation-info-panel { padding: 0.8rem 1rem; } }
        
        #spread-table { justify-content: flex-start; padding: max(2vh, 1rem) 1rem 1rem; height: 100%; }
        #table-prompt { flex-shrink: 0; margin-bottom: 1rem; min-height: 70px; }
        
        #chosen-cards-area { flex-shrink: 0; width: 100%; max-width: 800px; margin-bottom: 1rem; padding: 0.5rem; min-height: 150px; display: flex; justify-content: center; align-items: center; gap: 1.5rem; }
        .card-slot { width: 90px; height: 153px; border: 2px dashed var(--border-color); border-radius: 8px; display: flex; flex-direction: column; justify-content: center; align-items: center; color: var(--text-dark); font-size: 0.8rem; transition: border-color 0.4s ease; position: relative; }
        .card-slot.filled { border-style: solid; border-color: var(--primary); }
        .card-slot .tarot-card { position: absolute; top: 0; left: 0; }

        #card-deck { position: relative; flex-grow: 1; width: 100%; max-width: 1100px; opacity: 0; pointer-events: none; overflow-y: auto; mask-image: linear-gradient(to bottom, black 90%, transparent 100%); -webkit-mask-image: linear-gradient(to bottom, black 90%, transparent 100%); min-height: 0; }
        .card-deck-inner { display: grid; gap: 1rem; padding: 1rem; width: 100%; grid-template-columns: repeat(5, 1fr); }
        @media (min-width: 600px) { .card-deck-inner { grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); } }
        
        .tarot-card { width: 100%; aspect-ratio: 80 / 136; border: 1px solid var(--border-color); border-radius: 8px; cursor: pointer; transition: transform 0.4s ease, box-shadow 0.4s ease; user-select: none; will-change: transform, box-shadow; position: relative; overflow: hidden; background: radial-gradient(ellipse at 50% 40%, rgba(192, 183, 232, 0.1) 0%, transparent 70%), linear-gradient(145deg, #1f1d47, #121222); box-shadow: 0 5px 15px var(--shadow-color), inset 0 0 20px rgba(10, 9, 26, 0.7); }
        .card-back-design { position: absolute; inset: 0; }
        .card-back-design .star { position: absolute; background-color: white; border-radius: 50%; box-shadow: 0 0 6px 2px rgba(212, 203, 255, 0.7); animation: twinkle 4s ease-in-out infinite; }
        @keyframes twinkle { 0%, 100% { opacity: 0.7; transform: scale(0.9); } 50% { opacity: 1; transform: scale(1.1); } }
        .card-back-design .star:nth-child(1) { top: 30%; left: 25%; width: 2px; height: 2px; animation-delay: 0s; }
        .card-back-design .star:nth-child(2) { top: 50%; left: 20%; width: 3px; height: 3px; animation-delay: 0.5s; }
        .card-back-design .star:nth-child(3) { top: 55%; left: 50%; width: 2.5px; height: 2.5px; animation-delay: 1.2s; }
        .card-back-design .star:nth-child(4) { top: 35%; left: 55%; width: 2px; height: 2px; animation-delay: 2s; }
        .card-back-design .star:nth-child(5) { top: 30%; left: 75%; width: 3px; height: 3px; animation-delay: 1.5s; }
        .card-back-design .star:nth-child(6) { top: 20%; left: 90%; width: 2.5px; height: 2.5px; animation-delay: 0.8s; }
        .card-back-design .star:nth-child(7) { top: 10%; left: 85%; width: 2px; height: 2px; animation-delay: 2.5s; }

        .tarot-card:hover { transform: translateY(-5px) scale(1.03); box-shadow: 0 8px 25px var(--shadow-color), inset 0 0 20px rgba(10, 9, 26, 0.7); }
        .tarot-card.is-flying { pointer-events: none; z-index: 50; }

        #spread-actions { display: flex; gap: 1rem; margin-top: 1rem; flex-shrink: 0; opacity: 0; transition: opacity 0.5s ease; pointer-events: none; }
        .primary-btn { font-family: 'Cinzel', serif; font-size: 1rem; letter-spacing: 0.1em; color: var(--text-light); background: transparent; border: 1px solid var(--border-color); padding: 0.8rem 2rem; border-radius: 50px; cursor: pointer; transition: all 0.4s ease; backdrop-filter: blur(5px); will-change: transform, box-shadow; }
        
        /* ★★★★★★★★★★★ 결과 화면 레이아웃 및 기능 개선 ★★★★★★★★★★★ */
        #reading-result { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(10, 9, 26, 0.7); backdrop-filter: blur(10px); z-index: 100; display: flex; justify-content: center; align-items: center; opacity: 0; pointer-events: none; transition: opacity 0.5s ease; }
        #reading-result.visible { opacity: 1; pointer-events: auto; }
        #result-content { background: radial-gradient(circle at 50% 0%, rgba(28, 26, 58, 0.7), var(--bg-dark) 80%); border: 1px solid var(--border-color); border-radius: 1.5rem; width: 90%; max-width: 850px; max-height: 90vh; padding: 2rem; box-shadow: 0 20px 50px var(--shadow-color); transform: scale(0.95); transition: transform 0.5s cubic-bezier(0.165, 0.84, 0.44, 1); display: flex; flex-direction: column; }
        #result-main-view { display: flex; gap: 2rem; flex: 1; min-height: 0; padding-bottom: 1rem; /* 내용이 버튼과 겹치지 않게 패딩 추가 */ }
        
        #result-card-display { flex-basis: 160px; /* 카드 크기 축소 */ flex-shrink: 0; text-align: center; perspective: 1000px; cursor: zoom-in; }
        #result-card-flipper { width: 100%; margin: 0 auto 1rem; position: relative; transform-style: preserve-3d; transition: transform 0.8s cubic-bezier(0.25, 1, 0.5, 1); }
        #result-card-image { width: 100%; box-shadow: 0 10px 35px rgba(0,0,0,0.5); border-radius: 12px; position: relative; transform-style: preserve-3d; backface-visibility: hidden; -webkit-backface-visibility: hidden; }
        #result-card-image::after { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; border-radius: 12px; box-shadow: inset 0 0 20px rgba(192, 183, 232, 0.6); opacity: 0.8; }
        #result-card-image img { width: 100%; border-radius: 10px; display: block; }
        
        #result-label { font-family: 'Pretendard', sans-serif; color: var(--primary); font-weight: 500; font-size: 1rem; }
        #result-text-content { flex: 1; display: flex; flex-direction: column; min-width: 0; text-align: left; }
        #result-card-name { font-family: 'Cinzel', serif; font-size: clamp(1.8rem, 5vw, 2.2rem); color: var(--text-light); margin-bottom: 0.5rem; letter-spacing: 0.05em; }
        #result-keywords { font-family: 'Pretendard', sans-serif; font-style: italic; color: var(--text-dark); font-size: 0.95rem; border-bottom: 1px solid var(--border-color); padding-bottom: 1rem; margin-bottom: 1rem; }
        #result-interpretation-wrapper { flex: 1; overflow-y: auto; min-height: 0; padding-right: 1rem; }
        
        #result-interpretation p { margin-bottom: 1em; opacity: 0; transform: translateY(20px); transition: opacity 0.6s ease, transform 0.6s ease; }
        #result-interpretation p.is-visible { opacity: 1; transform: translateY(0); }
        
        #result-interpretation-wrapper::-webkit-scrollbar { width: 6px; }
        #result-interpretation-wrapper::-webkit-scrollbar-track { background: transparent; }
        #result-interpretation-wrapper::-webkit-scrollbar-thumb { background-color: var(--text-dark); border-radius: 3px; }
        #result-interpretation-wrapper::-webkit-scrollbar-thumb:hover { background-color: var(--primary); }
        #result-actions { margin-top: 1rem; /* 겹침 문제 해결 후 여백 조정 */ padding-top: 1rem; border-top: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; width: 100%; flex-shrink: 0; }
        #result-actions .tertiary-btn { background: none; border: none; color: var(--text-dark); cursor: pointer; font-size: 0.9rem; transition: color 0.3s ease; }
        #result-actions .tertiary-btn:hover { color: var(--primary); }
        #close-result-btn { padding: 0.7rem 1.8rem; margin: 0; font-size: 0.9rem; }

        @media (max-width: 768px) {
            #result-content { padding: 1.5rem 1rem; }
            #result-main-view { flex-direction: column; gap: 1.5rem; }
            #result-card-display { flex-basis: auto; width: 40%; max-width: 140px; margin: 0 auto; } /* 모바일 카드 크기 축소 */
            #result-text-content { text-align: center; }
            #result-interpretation-wrapper { max-height: 28vh; }
            #result-interpretation { text-align: left; }
        }
        
        /* ★★★★★★★★★★★ 카드 크게 보기 기능 스타일 ★★★★★★★★★★★ */
        #enlarged-card-view {
            position: fixed;
            inset: 0;
            background-color: rgba(10, 9, 26, 0.7);
            backdrop-filter: blur(8px);
            z-index: 200;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: zoom-out;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease;
        }
        #enlarged-card-view.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #enlarged-card-view img {
            max-height: 85vh;
            max-width: 90%;
            width: auto;
            border-radius: 1rem;
            box-shadow: 0 20px 60px rgba(0,0,0,0.7);
            transform: scale(0.8);
            transition: transform 0.4s cubic-bezier(0.165, 0.84, 0.44, 1);
        }
        #enlarged-card-view.visible img {
            transform: scale(1);
        }
    </style>
</head>
<body>
    <div id="celestial-background"> <div id="aurora"></div> <div class="star-layer" id="stars-far"></div> <div class="star-layer" id="stars-mid"></div> <div class="star-layer" id="stars-near"></div> </div>
    <div id="app-root">
        <div id="entry-gate" class="ui-layer">
            <div class="prompt"> <h1>Moriah's Oracle</h1> <p id="subtitle" class="reveal-text" style="margin-top:1rem;">별들의 속삭임이 당신의 길을 비출 때,</p> </div>
        </div>
        <div id="celestial-pathway" class="ui-layer">
            <div class="prompt"> <svg id="pathway-lines" style="position:absolute;top:50%;left:50%;width:100%;height:100%;transform:translate(-50%,-50%);" viewBox="0 0 100 100" preserveAspectRatio="none"><path class="path-line" d="M 50 100 V 0" vector-effect="non-scaling-stroke" style="stroke:var(--primary);stroke-width:1;fill:none;opacity:0.5;"></path></svg> <h2>내면으로의 길</h2> <p class="reveal-text">그 속삭임을 따라, 내면으로의 길을 걷습니다.</p> </div>
        </div>
        <div id="focus-altar" class="ui-layer">
            <div class="prompt"> <h2>의지의 제단</h2> <p class="reveal-text">길의 끝에서, 당신의 의지를 하나로 모읍니다.<br>오브를 눌러 당신의 기운을 불어넣으세요.</p> </div>
            <div id="orb-effects-container"></div>
            <div id="focus-orb" style="width: 120px; height: 120px; margin: 2rem auto; cursor: pointer; position: relative;"> <div id="orb-ground-light"></div> <div id="orb-glow" style="position: absolute; top: 50%; left: 50%; border-radius: 50%; transform: translate(-50%, -50%); width: 100%; height: 100%; background: radial-gradient(circle, rgba(192, 183, 232, 0.4) 0%, transparent 70%);"></div> <div id="orb-core" style="position: absolute; top: 50%; left: 50%; border-radius: 50%; transform: translate(-50%, -50%); width: 70%; height: 70%; background: radial-gradient(circle, #fff 0%, var(--primary) 100%); opacity: 0.8;"></div> <div id="orb-flash" style="position: absolute; top: 50%; left: 50%; border-radius: 50%; transform: translate(-50%,-50%) scale(0); width: 300%; height: 300%; background: radial-gradient(circle, white 0%, transparent 60%); opacity: 0;"></div> </div>
        </div>
        <div id="focus-sanctum" class="ui-layer">
            <div class="prompt"> <h2>지혜의 성소</h2> <p>우주가 당신의 의지에 응답합니다.<br>운명의 강에서 별을 선택하여 당신의 길을 찾으세요.</p> </div>
            <div id="constellation-map-container">
                <svg id="constellation-svg" preserveAspectRatio="xMidYMid meet"></svg>
            </div>
            <div id="constellation-info-panel">
                <h3 id="info-panel-title"></h3>
                <p id="info-panel-desc"></p>
            </div>
        </div>
        <div id="spread-table" class="ui-layer">
            <div id="table-prompt" class="prompt"></div>
            <div id="chosen-cards-area"></div>
            <div id="card-deck"><div class="card-deck-inner"></div></div>
            <div id="spread-actions"><button id="shuffle-btn" class="primary-btn">카드 섞기</button><button id="reveal-btn" class="primary-btn" disabled>결과 보기</button></div>
        </div>
    </div>
    
    <div id="reading-result">
        <div id="result-content">
            <div id="result-main-view">
                <div id="result-card-display">
                    <div id="result-card-flipper">
                        <div id="result-card-image">
                            <img src="" alt="Tarot Card Image" />
                        </div>
                    </div>
                    <h3 id="result-label"></h3>
                </div>
                <div id="result-text-content">
                    <h2 id="result-card-name"></h2>
                    <p id="result-keywords"></p>
                    <div id="result-interpretation-wrapper">
                        <div id="result-interpretation"></div>
                    </div>
                </div>
            </div>
            <div id="result-actions">
                <button id="prev-card-btn" class="tertiary-btn">이전 카드</button>
                <button id="close-result-btn" class="primary-btn">다시 질문하기</button>
                <button id="next-card-btn" class="tertiary-btn">다음 카드</button>
            </div>
        </div>
    </div>
    
    <!-- ★★★★★★★★★★★ 카드 크게 보기 기능 HTML ★★★★★★★★★★★ -->
    <div id="enlarged-card-view">
        <img src="" alt="Enlarged Tarot Card" />
    </div>
    
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const app = {
            cardData: [],
            currentReading: null,
            chosenCards: [],
            currentResultIndex: 0,
            intersectionObserver: null,
            isTouchDevice: ('ontouchstart' in window) || (navigator.maxTouchPoints > 0),
            activeMobileStar: null,
        };
        const UIElements = {};
        const readingTypes = {};

        function init() {
            Object.assign(readingTypes, {
                'today': { icon: '☀️', ko: { title: '오늘의 운세', desc: '하루의 길잡이가 될 조언을 확인하세요.' }, labels: ['오늘의 조언'], cardsToDraw: 1 },
                'love': { icon: '❤️', ko: { title: '애정운', desc: '당신과 그 사람, 관계의 속마음을 들여다봅니다.' }, labels: ['나의 상황', '상대방의 마음', '관계의 미래'], cardsToDraw: 3 },
                'career': { icon: '💼', ko: { title: '취업운', desc: '당신의 강점과 약점을 파악하고 성공 전략을 세웁니다.' }, labels: ['나의 강점', '직면한 과제', '결과/조언'], cardsToDraw: 3 },
                'finance': { icon: '💰', ko: { title: '금전운', desc: '돈의 흐름을 파악하여 재정적 풍요를 위한 조언을 얻습니다.' }, labels: ['현재 재정', '돈의 흐름', '상승 조언'], cardsToDraw: 3 },
                'general': { icon: '🍀', ko: { title: '일반운', desc: '과거부터 미래까지, 삶의 큰 흐름을 읽어봅니다.' }, labels: ['과거', '현재', '미래'], cardsToDraw: 3 },
                'business': { icon: '💡', ko: { title: '사업운', desc: '사업의 흐름을 분석하고 성공의 열쇠를 찾습니다.' }, labels: ['현재 상황', '장애물', '성공의 열쇠'], cardsToDraw: 3 }
            });

            Object.assign(UIElements, {
                gate: document.getElementById('entry-gate'),
                pathway: document.getElementById('celestial-pathway'),
                altar: document.getElementById('focus-altar'),
                sanctum: document.getElementById('focus-sanctum'),
                table: document.getElementById('spread-table'),
                tablePrompt: document.querySelector('#table-prompt'),
                focusOrb: document.getElementById('focus-orb'),
                orbGlow: document.getElementById('orb-glow'),
                orbCore: document.getElementById('orb-core'),
                orbEffects: document.getElementById('orb-effects-container'),
                constellationSvg: document.getElementById('constellation-svg'),
                constellationInfoPanel: document.getElementById('constellation-info-panel'),
                infoPanelTitle: document.getElementById('info-panel-title'),
                infoPanelDesc: document.getElementById('info-panel-desc'),
                chosenCardsArea: document.getElementById('chosen-cards-area'),
                cardDeck: document.getElementById('card-deck'),
                cardDeckInner: document.querySelector('#card-deck .card-deck-inner'),
                spreadActions: document.getElementById('spread-actions'),
                revealBtn: document.getElementById('reveal-btn'),
                shuffleBtn: document.getElementById('shuffle-btn'),
                readingResult: document.getElementById('reading-result'),
                resultContent: document.getElementById('result-content'),
                resultCardDisplay: document.getElementById('result-card-display'), // 카드 크게 보기를 위해 추가
                resultFlipper: document.getElementById('result-card-flipper'),
                closeResultBtn: document.getElementById('close-result-btn'),
                prevCardBtn: document.getElementById('prev-card-btn'),
                nextCardBtn: document.getElementById('next-card-btn'),
                enlargedCardView: document.getElementById('enlarged-card-view'), // 카드 크게 보기 뷰
                enlargedCardImage: document.querySelector('#enlarged-card-view img'), // 카드 크게 보기 이미지
            });
            
            loadCardData();
            setupEventListeners();
            startIntroSequence();
        }

        function setupEventListeners() {
            document.body.addEventListener('mousemove', (e) => {
                if(app.isTouchDevice) return;
                const x = (e.clientX / window.innerWidth - 0.5);
                const y = (e.clientY / window.innerHeight - 0.5);
                gsap.to(['#stars-far', '#stars-mid', '#stars-near'], { x: (i) => -x * 15 * (i + 1), y: (i) => -y * 15 * (i + 1), duration: 2, ease: 'power2.out' });
            });

            UIElements.focusOrb.addEventListener('click', handleOrbClick);
            UIElements.shuffleBtn.addEventListener('click', handleShuffleClick);
            UIElements.revealBtn.addEventListener('click', showResult);
            UIElements.closeResultBtn.addEventListener('click', () => {
                gsap.to(UIElements.resultContent, {
                    opacity: 0, scale: 0.9, y: 20, duration: 0.4, ease: 'power2.in',
                    onComplete: () => {
                        UIElements.readingResult.classList.remove('visible');
                        resetSpread();
                        transitionToScene(UIElements.table, UIElements.sanctum);
                    }
                });
            });
            UIElements.prevCardBtn.addEventListener('click', () => navigateResult(-1));
            UIElements.nextCardBtn.addEventListener('click', () => navigateResult(1));

            if (!app.isTouchDevice) {
                UIElements.constellationSvg.addEventListener('mouseover', handleConstellationHover);
                UIElements.constellationSvg.addEventListener('mouseout', handleConstellationLeave);
            }
            UIElements.constellationSvg.addEventListener('click', (e) => {
                if (e.target.tagName.toLowerCase() === 'svg' && app.activeMobileStar) {
                    deactivateActiveMobileStar();
                }
            });
            
            // ★★★★★★★★★★★ 카드 크게 보기 이벤트 리스너 추가 ★★★★★★★★★★★
            UIElements.resultCardDisplay.addEventListener('click', showEnlargedCard);
            UIElements.enlargedCardView.addEventListener('click', hideEnlargedCard);
        }
        
        function handleOrbClick() {
            if (gsap.isTweening(UIElements.focusOrb)) return;
            
            const tl = gsap.timeline({ onComplete: () => {
                transitionToScene(UIElements.altar, UIElements.sanctum);
                gsap.set(UIElements.focusOrb, { scale: 1, opacity: 1 });
                gsap.set([UIElements.orbGlow, UIElements.orbCore], { scale: 1 });
            }});
            
            tl.to(UIElements.focusOrb, { scale: 1.1, duration: 0.3, ease: 'power2.out' })
              .to('#orb-flash', { scale: 1, opacity: 0.7, duration: 0.4, ease: 'power2.out' }, "-=0.2")
              .to(UIElements.focusOrb, { scale: 1.5, opacity: 0, duration: 0.5, ease: 'power2.in' }, "-=0.3")
              .to('#orb-flash', { opacity: 0, duration: 0.5 }, "<");
        }

        function transitionToScene(from, to, onComplete) {
            deactivateActiveMobileStar();
            const tl = gsap.timeline({
                onComplete: () => {
                    from.style.pointerEvents = 'none';
                    to.style.pointerEvents = 'auto';
                    if (to === UIElements.pathway) {
                        const pathLine = UIElements.pathway.querySelector('.path-line');
                        gsap.set(pathLine, { strokeDasharray: 100, strokeDashoffset: 100 });
                        gsap.to(pathLine, { strokeDashoffset: 0, duration: 2.5, delay: 0.5, ease: 'power1.inOut', onComplete: () => setTimeout(() => transitionToScene(UIElements.pathway, UIElements.altar), 1500) });
                    }
                    if (to === UIElements.altar) { startOrbEffects(); } else { stopOrbEffects(); }
                    if (to === UIElements.sanctum) { populateConstellationMap(); }
                    
                    if (onComplete) onComplete();
                }
            });

            tl.set(from, { pointerEvents: 'none' })
              .to(from, { duration: 0.8, z: -400, opacity: 0, ease: 'power2.in' })
              .to(to, { duration: 1.0, z: 0, opacity: 1, ease: 'power2.out' }, ">")
              .from(to.querySelectorAll('.prompt > h1, .prompt > h2, .prompt > p:not(.reveal-text), #focus-orb, #constellation-map-container'), { duration: 0.8, y: 40, opacity: 0, stagger: 0.1, ease: 'power2.out' }, "-=0.8")
              .add(() => {
                  const textElement = to.querySelector('.reveal-text');
                  if (textElement) animateTextReveal(textElement);
              }, "-=0.6");
        }

        function startReading(type) {
            deactivateActiveMobileStar();
            app.currentReading = readingTypes[type];
            app.chosenCards = [];
            UIElements.revealBtn.disabled = true;
            
            UIElements.chosenCardsArea.innerHTML = '';
            for (let i = 0; i < app.currentReading.cardsToDraw; i++) {
                const slot = document.createElement('div');
                slot.className = 'card-slot';
                slot.dataset.slotIndex = i;
                slot.innerHTML = `<span>${app.currentReading.labels[i] || `카드 ${i+1}`}</span>`;
                UIElements.chosenCardsArea.appendChild(slot);
            }

            updatePromptText();
            populateCardDeck();
            transitionToScene(UIElements.sanctum, UIElements.table, () => {
                gsap.to(UIElements.cardDeck, { y: 0, opacity: 1, duration: 1, ease: 'power2.out', pointerEvents: 'auto' });
                gsap.to(UIElements.spreadActions, { opacity: 1, pointerEvents: 'auto', duration: 0.5 });
            });
        }
        
        function populateCardDeck(isShuffle = false) {
            const cardCount = 20;
            const chosenIds = new Set(app.chosenCards.map(c => c.id));
            const unselectedPool = app.cardData.filter(c => !chosenIds.has(c.id));
            const shuffledUnselected = [...unselectedPool].sort(() => 0.5 - Math.random());
            const displayCardsData = shuffledUnselected.slice(0, cardCount);

            UIElements.cardDeckInner.innerHTML = "";
            UIElements.cardDeck.scrollTop = 0;

            displayCardsData.forEach((cardData) => {
                const cardElement = document.createElement("div");
                cardElement.className = "tarot-card";
                cardElement.dataset.cardId = cardData.id;

                const cardBack = document.createElement("div");
                cardBack.className = "card-back-design";
                for(let i = 0; i < 7; i++) {
                    const star = document.createElement("span");
                    star.className = "star";
                    cardBack.appendChild(star);
                }
                cardElement.appendChild(cardBack);

                cardElement.addEventListener('click', handleCardSelection, { once: true });
                UIElements.cardDeckInner.appendChild(cardElement);
            });

            const cards = UIElements.cardDeckInner.children;
            gsap.set(cards, { x: 0, y: 0, rotation: 0, scale: 1, opacity: 1 });
            
            if (isShuffle) {
                 gsap.from(cards, {
                    x: () => UIElements.cardDeckInner.clientWidth / 2 - 45,
                    y: () => UIElements.cardDeckInner.clientHeight,
                    rotation: () => (Math.random() - 0.5) * 60,
                    scale: 0,
                    duration: 0.8,
                    ease: 'power3.out',
                    stagger: 0.05
                });
            } else {
                gsap.from(cards, {
                    x: () => UIElements.cardDeckInner.clientWidth / 2 - 45,
                    y: () => UIElements.cardDeckInner.clientHeight / 2,
                    scale: 0,
                    rotation: (i) => (i - (cards.length - 1) / 2) * -10,
                    opacity: 0,
                    duration: 1,
                    ease: 'power4.out',
                    stagger: { each: 0.05, from: "center" }
                });
            }
        }
        
        function handleCardSelection(e) {
            if (app.chosenCards.length >= app.currentReading.cardsToDraw) return;
            
            const cardElement = e.currentTarget;
            cardElement.classList.add('is-flying');
            
            const cardId = parseInt(cardElement.dataset.cardId, 10);
            const cardData = app.cardData.find(c => c.id === cardId);
            const targetSlot = UIElements.chosenCardsArea.querySelector('.card-slot:not(.filled)');
            
            if (!targetSlot) return;
            
            const slotIndex = parseInt(targetSlot.dataset.slotIndex, 10);
            const cardInfo = { ...cardData, isReversed: Math.random() < 0.3, slotIndex };
            app.chosenCards.push(cardInfo);
            
            const startRect = cardElement.getBoundingClientRect();
            const endRect = targetSlot.getBoundingClientRect();
            
            const flyingCard = cardElement.cloneNode(true);
            document.body.appendChild(flyingCard);
            gsap.set(flyingCard, {
                position: 'fixed',
                top: startRect.top,
                left: startRect.left,
                width: startRect.width,
                height: startRect.height,
                zIndex: 1000
            });
            cardElement.style.opacity = '0';
            
            gsap.to(flyingCard, {
                x: endRect.left - startRect.left,
                y: endRect.top - startRect.top,
                width: endRect.width,
                height: endRect.height,
                rotation: cardInfo.isReversed ? 180 : 0,
                duration: 0.8,
                ease: 'power3.inOut',
                onComplete: () => {
                    targetSlot.appendChild(flyingCard);
                    gsap.set(flyingCard, { position: 'absolute', top: 0, left: 0, x: 0, y: 0, zIndex: 1 });
                    targetSlot.classList.add('filled');
                    flyingCard.addEventListener('click', () => handleChosenCardClick(cardId, targetSlot, flyingCard));
                }
            });

            updateCardSelectionState();
        }

        function handleChosenCardClick(cardId, slotElement, cardElement) {
             gsap.to(cardElement, {
                scale: 0,
                opacity: 0,
                rotation: '+=45',
                duration: 0.4,
                ease: 'power2.in',
                onComplete: () => {
                    cardElement.remove();
                    slotElement.classList.remove('filled');
                    app.chosenCards = app.chosenCards.filter(c => c.id !== cardId);
                    updateCardSelectionState();
                    populateCardDeck(true);
                }
            });
        }
        
        function handleShuffleClick() {
            if(gsap.isTweening('.tarot-card')) return;
            const cards = UIElements.cardDeckInner.children;
            const deckRect = UIElements.cardDeckInner.getBoundingClientRect();
            
            gsap.to(cards, {
                x: (i, target) => deckRect.width / 2 - target.offsetLeft - target.offsetWidth / 2,
                y: (i, target) => deckRect.height / 2 - target.offsetTop - target.offsetHeight / 2,
                scale: 0,
                opacity: 0,
                rotation: () => (Math.random() - 0.5) * 180,
                duration: 0.7,
                stagger: 0.03,
                ease: 'power2.in',
                onComplete: () => populateCardDeck(true)
            });
        }

        function updateCardSelectionState() {
            updatePromptText();
            const readyToReveal = app.chosenCards.length === app.currentReading.cardsToDraw;
            UIElements.revealBtn.disabled = !readyToReveal;
            gsap.killTweensOf(UIElements.revealBtn);
            if (readyToReveal) {
                gsap.to(UIElements.revealBtn, { scale: 1.05, borderColor: 'var(--primary)', boxShadow: '0 0 15px rgba(192, 183, 232, 0.5)', repeat: -1, yoyo: true, duration: 1.2, ease: 'power1.inOut' });
            } else {
                gsap.to(UIElements.revealBtn, { scale: 1, borderColor: 'var(--border-color)', boxShadow: '0 0 0 rgba(192, 183, 232, 0)', duration: 0.4 });
            }
        }

        function updatePromptText() {
            const remaining = app.currentReading.cardsToDraw - app.chosenCards.length;
            let text = remaining > 0 ? `운명의 카드를 ${remaining}장 더 선택하세요.` : "모든 카드를 선택했습니다. 결과를 확인하세요.";
            UIElements.tablePrompt.innerHTML = `<h2>${app.currentReading.ko.title}</h2><p>${text}</p>`;
        }

        function showResult() {
            app.currentResultIndex = 0;
            app.chosenCards.sort((a, b) => a.slotIndex - b.slotIndex);

            populateResult(app.chosenCards[0]);
            UIElements.readingResult.classList.add("visible");
            gsap.killTweensOf(UIElements.revealBtn);
            gsap.to(UIElements.revealBtn, { scale: 1, borderColor: 'var(--border-color)', boxShadow: '0 0 0 rgba(192, 183, 232, 0)', duration: 0.4 });
            
            const tl = gsap.timeline();
            tl.fromTo(UIElements.resultContent, { opacity: 0, scale: 0.9, y: 20 }, { opacity: 1, scale: 1, y: 0, duration: 0.6, ease: 'cubic-bezier(0.165, 0.84, 0.44, 1)' });
            tl.from(UIElements.resultFlipper, { rotationY: -90, opacity: 0, duration: 0.7, ease: 'power2.out' }, "-=0.3");
            tl.from(UIElements.readingResult.querySelector('#result-text-content').children, { opacity: 0, y: 20, duration: 0.5, stagger: 0.1, ease: 'power2.out' }, "-=0.4");
            tl.from(UIElements.readingResult.querySelector('#result-actions'), { opacity: 0, duration: 0.4 }, "-=0.5");
            
            setupIntersectionObserver();
        };
        
        function setupIntersectionObserver() {
            if (app.intersectionObserver) app.intersectionObserver.disconnect();
            
            const options = { root: UIElements.readingResult.querySelector('#result-interpretation-wrapper'), rootMargin: '0px', threshold: 0.1 };
            
            app.intersectionObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('is-visible');
                    }
                });
            }, options);

            const paragraphs = UIElements.readingResult.querySelectorAll('#result-interpretation p');
            paragraphs.forEach(p => app.intersectionObserver.observe(p));
        }

        function navigateResult(direction) {
            const cardCount = app.chosenCards.length;
            if (cardCount <= 1 || gsap.isTweening(UIElements.resultFlipper)) return;

            const newIndex = (app.currentResultIndex + direction + cardCount) % cardCount;
            app.currentResultIndex = newIndex;

            gsap.timeline({ onComplete: setupIntersectionObserver })
                .to(UIElements.resultFlipper, { rotationY: '+=90', duration: 0.4, ease: 'power2.in' })
                .add(() => populateResult(app.chosenCards[app.currentResultIndex]))
                .set(UIElements.resultFlipper, { rotationY: '-=90' })
                .to(UIElements.resultFlipper, { rotationY: 0, duration: 0.4, ease: 'power2.out' });
        };
        
        function populateResult(card) {
            if (!card) return;
            const resultRoot = document.getElementById('reading-result');
            const img = resultRoot.querySelector("#result-card-image img");
            const labelEl = resultRoot.querySelector("#result-label");
            const nameEl = resultRoot.querySelector("#result-card-name");
            const keywordsEl = resultRoot.querySelector("#result-keywords");
            const interpretationEl = resultRoot.querySelector("#result-interpretation");
            const interpretationWrapper = resultRoot.querySelector("#result-interpretation-wrapper");
            const prevBtn = resultRoot.querySelector("#prev-card-btn");
            const nextBtn = resultRoot.querySelector("#next-card-btn");

            const labels = app.currentReading.labels || [];
            img.src = card.imageUrl || `https://via.placeholder.com/220x374`;
            img.alt = `${card.name_kr} Card`;
            
            UIElements.resultFlipper.style.transform = card.isReversed ? "rotate(180deg)" : "rotate(0deg)";
            
            labelEl.textContent = labels[app.currentResultIndex] || '당신의 카드';
            nameEl.textContent = `${card.name_kr}${card.isReversed ? " (역방향)" : ""}`;
            
            const keywords = card.isReversed ? card.reversed_keywords || [] : card.upright_keywords || [];
            keywordsEl.textContent = keywords.join(" · ");
            
            const meaning = card.isReversed ? card.reversed_meaning || {} : card.meaning || {};
            const interpretationText = meaning.general || "해설을 준비 중입니다.";
            interpretationEl.innerHTML = `<p>${interpretationText.replace(/\n/g, '</p><p>')}</p>`;
            interpretationWrapper.scrollTop = 0;

            const hasMultipleCards = app.chosenCards.length > 1;
            prevBtn.style.visibility = hasMultipleCards ? "visible" : "hidden";
            nextBtn.style.visibility = hasMultipleCards ? "visible" : "hidden";
        };
        
        // ★★★★★★★★★★★ 카드 크게 보기 기능 함수 ★★★★★★★★★★★
        function showEnlargedCard() {
            const currentCard = app.chosenCards[app.currentResultIndex];
            if (!currentCard) return;
            
            UIElements.enlargedCardImage.src = currentCard.imageUrl;
            UIElements.enlargedCardView.classList.add('visible');
        }

        function hideEnlargedCard() {
            UIElements.enlargedCardView.classList.remove('visible');
        }

        function resetSpread() {
            UIElements.cardDeckInner.innerHTML = "";
            UIElements.chosenCardsArea.innerHTML = "";
            gsap.set(UIElements.cardDeck, { opacity: 0, pointerEvents: "none" });
            app.currentReading = null;
            app.chosenCards = [];
            gsap.to(UIElements.spreadActions, { opacity: 0, pointerEvents: 'none', duration: 0.3 });
            UIElements.revealBtn.disabled = true;
        };

        function loadCardData() {
            if (typeof tarotData !== 'undefined' && Array.isArray(tarotData)) {
                app.cardData = tarotData;
            } else {
                console.error("Card data could not be loaded from tarot_data.js");
                app.cardData = [];
            }

            if (app.cardData.length < 78) {
                const placeholder = { id: 0, name_kr: "카드", imageUrl: "https://via.placeholder.com/220x374", upright_keywords: ["시작"], reversed_keywords: ["정체"], meaning: { general: "해석" }, reversed_meaning: { general: "해석" } };
                while (app.cardData.length < 78) {
                    const i = app.cardData.length;
                    app.cardData.push({ ...placeholder, id: i, name_kr: `카드 ${i}` });
                }
            }
        };
        
        function populateConstellationMap() {
            const svg = UIElements.constellationSvg;
            svg.innerHTML = '';

            const svgWidth = 800;
            const svgHeight = 800; 
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            
            const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
            const linearGradient = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
            linearGradient.setAttribute("id", "line-gradient");
            linearGradient.setAttribute("x1", "0%");
            linearGradient.setAttribute("y1", "0%");
            linearGradient.setAttribute("x2", "0%");
            linearGradient.setAttribute("y2", "100%");
            linearGradient.innerHTML = `
                <stop offset="0%" style="stop-color:rgba(192, 183, 232, 0.2);" />
                <stop offset="50%" style="stop-color:rgba(192, 183, 232, 0.8);" />
                <stop offset="100%" style="stop-color:rgba(192, 183, 232, 0.2);" />
            `;
            defs.appendChild(linearGradient);
            svg.appendChild(defs);

            const typesInOrder = ['today', 'love', 'career', 'finance', 'general', 'business'];
            const numTypes = typesInOrder.length;
            const startY = 80;
            const endY = svgHeight - 80;
            const yStep = (endY - startY) / (numTypes > 1 ? numTypes - 1 : 1);
            const centerX = svgWidth / 2;
            const xOffset = 120;
            
            let prevCoords = null;

            typesInOrder.forEach((type, i) => {
                const reading = readingTypes[type];
                if (reading) {
                    const yPos = startY + i * yStep;
                    const xPos = (i % 2 === 0) ? centerX - xOffset : centerX + xOffset;

                    if (prevCoords) {
                        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        line.setAttribute('x1', prevCoords.x);
                        line.setAttribute('y1', prevCoords.y);
                        line.setAttribute('x2', xPos);
                        line.setAttribute('y2', yPos);
                        line.classList.add('constellation-line');
                        svg.appendChild(line);
                        gsap.from(line, { opacity: 0, duration: 1, delay: 0.5 + i * 0.1 });
                    }
                    prevCoords = { x: xPos, y: yPos };

                    const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
                    group.dataset.readingType = type;
                    group.style.cursor = 'pointer';

                    const glow = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    glow.setAttribute('cx', xPos); glow.setAttribute('cy', yPos);
                    glow.setAttribute('r', 20); glow.classList.add('star-glow');
                    
                    const starNode = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    starNode.setAttribute('cx', xPos); starNode.setAttribute('cy', yPos);
                    starNode.setAttribute('r', 10); starNode.classList.add('star-node');
                    
                    const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    const labelOffset = 30;
                    
                    if (i % 2 === 0) {
                        label.setAttribute('x', xPos - labelOffset);
                        label.setAttribute('text-anchor', 'end');
                    } else {
                        label.setAttribute('x', xPos + labelOffset);
                        label.setAttribute('text-anchor', 'start');
                    }
                    label.setAttribute('y', yPos);
                    label.setAttribute('dy', '0.3em');
                    label.textContent = reading.ko.title; 
                    label.classList.add('star-label');
                    
                    group.appendChild(glow);
                    group.appendChild(starNode);
                    group.appendChild(label);
                    group.addEventListener('click', () => handleStarClick(type));
                    svg.appendChild(group);

                    gsap.from(group, { scale: 0, opacity: 0, duration: 0.8, ease: 'back.out(1.7)', delay: 0.5 + i * 0.1 });
                }
            });
        }
        
        function handleStarClick(type) {
            if (app.isTouchDevice) {
                if (app.activeMobileStar === type) {
                    startReading(type);
                } else {
                    deactivateActiveMobileStar();
                    app.activeMobileStar = type;
                    const group = UIElements.constellationSvg.querySelector(`g[data-reading-type="${type}"]`);
                    if (group) {
                        activateStar(group);
                    }
                }
            } else {
                startReading(type);
            }
        }

        function activateStar(group) {
            const type = group.dataset.readingType;
            const reading = readingTypes[type];
            if (reading) {
                UIElements.infoPanelTitle.textContent = reading.ko.title;
                UIElements.infoPanelDesc.textContent = reading.ko.desc;
                UIElements.constellationInfoPanel.classList.add('visible');
                
                gsap.to(UIElements.constellationInfoPanel, { opacity: 1, y: 0, duration: 0.3, ease: 'power2.out' });
                gsap.to(group.querySelector('.star-node'), { r: 12, fill: 'white', duration: 0.3 });
                gsap.to(group.querySelector('.star-glow'), { r: 25, opacity: 0.6, duration: 0.3 });
            }
        }
        
        function deactivateStar(group) {
            if (group) {
                gsap.to(group.querySelector('.star-node'), { r: 10, fill: 'rgba(255, 255, 255, 0.7)', duration: 0.3 });
                gsap.to(group.querySelector('.star-glow'), { r: 20, opacity: 0.3, duration: 0.3 });
            }
        }
        
        function deactivateActiveMobileStar() {
            if (app.activeMobileStar) {
                const oldGroup = UIElements.constellationSvg.querySelector(`g[data-reading-type="${app.activeMobileStar}"]`);
                deactivateStar(oldGroup);
                app.activeMobileStar = null;
                gsap.to(UIElements.constellationInfoPanel, { opacity: 0, y: 20, duration: 0.3, ease: 'power2.in', onComplete: () => {
                    UIElements.constellationInfoPanel.classList.remove('visible');
                }});
            }
        }

        function handleConstellationHover(event) {
            const group = event.target.closest('g');
            if (group && !gsap.isTweening(group)) {
                activateStar(group);
            }
        }

        function handleConstellationLeave(event) {
            const group = event.target.closest('g');
            if (group) {
                 gsap.to(UIElements.constellationInfoPanel, { opacity: 0, y: 20, duration: 0.3, ease: 'power2.in', onComplete: () => {
                    if(!UIElements.constellationSvg.matches(':hover')) {
                        UIElements.constellationInfoPanel.classList.remove('visible');
                    }
                }});
                deactivateStar(group);
            }
        }
        
        function animateTextReveal(element, onCompleteCallback) { 
            if (!element || !element.textContent) { if(onCompleteCallback) onCompleteCallback(); return; }
            const originalText = element.innerHTML; 
            element.innerHTML = "";
            gsap.set(element, { opacity: 1 });

            const tempDiv = document.createElement('div'); 
            tempDiv.innerHTML = originalText; 
            let spans = []; 
            Array.from(tempDiv.childNodes).forEach(node => { 
                if (node.nodeType === Node.TEXT_NODE) { 
                    node.textContent.split("").forEach(char => { 
                        const span = document.createElement('span'); 
                        span.style.cssText = "display: inline-block; opacity: 0; transform: translateY(10px);"; 
                        span.textContent = char === ' ' ? '\u00A0' : char; 
                        element.appendChild(span); 
                        spans.push(span); 
                    }); 
                } else if (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'BR') { 
                    element.appendChild(document.createElement('br')); 
                } 
            }); 
            gsap.to(spans, { 
                duration: 0.5, 
                opacity: 1, 
                y: 0, 
                textShadow: "0 0 15px rgba(192, 183, 232, 0.7)", 
                stagger: { each: 0.08, from: "start" }, 
                ease: "power2.out", 
                onComplete: onCompleteCallback 
            }); 
        };
        
        function startIntroSequence() {
            const title = UIElements.gate.querySelector("h1");
            const subtitle = document.getElementById('subtitle');
            gsap.set(UIElements.gate, { pointerEvents: 'none' });
            gsap.set(title, { opacity: 0, y: 20 });
            gsap.to(title, { duration: 1.2, y: 0, opacity: 1, ease: 'power2.out', delay: 0.5 });
            
            setTimeout(() => {
                animateTextReveal(subtitle, () => {
                    setTimeout(() => {
                        transitionToScene(UIElements.gate, UIElements.pathway);
                    }, 2000);
                });
            }, 1000);
        };

        function startOrbEffects() { 
            const container = UIElements.orbEffects; 
            container.innerHTML = ''; 
            for (let i = 0; i < 15; i++) { 
                const mote = document.createElement('div'); 
                mote.style.cssText = `
                    position: absolute; top: 50%; left: 50%; width: 3px; height: 3px;
                    background-color: rgba(255, 255, 255, 0.8); border-radius: 50%;
                    box-shadow: 0 0 10px white;
                `;
                container.appendChild(mote); 
                gsap.fromTo(mote, 
                    { x: 0, y: 0, opacity: 1, scale: 1 }, 
                    { 
                        x: () => (Math.random() - 0.5) * 200,
                        y: () => (Math.random() - 0.5) * 200,
                        opacity: 0,
                        scale: 0, 
                        duration: 3 + Math.random() * 3, 
                        ease: 'power1.out', 
                        repeat: -1, 
                        delay: Math.random() * 5 
                    }); 
            } 
        };
        
        function stopOrbEffects() { 
            const container = UIElements.orbEffects; 
            gsap.killTweensOf(container.children); 
            container.innerHTML = ''; 
        };
        
        init();
    });
    </script>
</body>
</html>